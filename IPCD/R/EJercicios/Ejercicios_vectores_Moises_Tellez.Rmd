---
title: "Ejercicios Vectores"
author: "Moisés Téllez Francisco"
date: "2023-09-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Ejercicios Vectores

1.  Crea un vector de números impares entre el 1 y el 30

-   Para realizar esto podemos utilizar la orden seq tal que

```{r}
ej1 <- seq(1,30, by=2)
print(ej1)
```

-   De este modo lo que hacemos es crear una secuencia entre 1 y 30 tal que empezamos en el numero 1 y vamos sumando de 2 en dos para generar todos los numeros impares.

2.  Crea los siguientes vectores

-   Un vector del 1 al 20:

Para ello podemos utilizar la creacion basica de vectores de R

```{r}
ej2a <- 1:20
print(ej2a)
```

-   Un vector del 20 al 1 Podemos utilizar de la misma forma la creación básica de vectores de R

```{r}
ej2b <- 20:1
print(ej2b)
```

-   un vector que tenga el siguiente patrón 1,2,3,...,19,20,19,18,...,2,1 Para ello no podemos utilizar la orden seq directamente o la creación basica de vectores de R. Pero por ejemplo podemos utilizar la funcion generica c que combina elementos. En este caso los dos vectores que hemos creado antes. Sin embargo, no podemos utilizarlo tal cual, porque tendriamos entonces el elemento con valor 20 por duplicado. Por tanto lo que vamos a combinar es el primer vector con todos los elementos del segundo menos el primero. De esta forma si obtenemos el vector deseado

```{r}
ej2c <- c(ej2a,ej2b[-1])
print(ej2c)
```

3.  Crea una secuencia de números del 1 al 30 con un incremento de 0.5 Podemos hacer esto facilmente utilizando la orden seq

```{r}
ej3 <- seq(1,30,by=0.5)
print(ej3)
```

4.  Crea una secuencia que contenga las cuatro primeras letras del abecedario 6 veces

Contamos con el vector auxiliar letters donde tenemos todo el abecedario. Así que podemos utilizarlo. Para introducir varios elementos de forma repetida tenemos que utilizar la orden rep. La cual nos ofrece dos posibilidades de hacer esto. Una en la que el vector contenga las 4 primeras letras letras del abecedario 6 veces secuencialmente, es decir: a,b,c,d,a,b,c,d... u otra en la que contenga 6 veces cada una de las 4 primeras letras. Es decir: a,a,a,a,a,a,b,b... Como no esta especificado vamos a resolver el ejercicio usando ambas formas

```{r}
ej4a <-rep(letters[1:4],6)
print(ej4a)

```

```{r}
ej4b <-rep(letters[1:4],each=6)
print(ej4b)
```

5.  Crea el vector numérico x con los valores 2.3, 3.3, 4.3 y accede al segundo elemento del vector

Para ello simplemente lo creamos utilizando la orden c que hemos utilizado anteriormente y accedemos al indice 2 (R indexa empezando en 1)

```{r}
ej5 <- c(2.3,3.3,4.3)
print(ej5[2])
```

6.  Crea un vector numérico z que contenga del 1 al 10. Cambia la clase del vector forzando que sea de tipo carácter. Después cambia el vector z a numerico de nuevo

Creamos el vector utilizando la orden seq. Para cambiar la clase podemos utilizar la funcion as.character y luego devolverlo a numerico usando as.numeric

```{r}
ej6<- seq(1,10)
class(ej6)
```

Ahi podemos ver como el vector que hemos creado es de tipo entero. Sin embargo el tipo "integer" realmente es un subconjunto del tipo numerico. Podemos comprobarlo utilizando la funcion is.numeric()

```{r}
is.numeric(ej6)
```

```{r}
ej6<- as.character(ej6)
class(ej6)
```

Despues lo cambiamos a carácter

```{r}
ej6<- as.numeric(ej6)
class(ej6)
```

Y lo devolvemos a numerico

7.  Crea un vector de con valores no ordenados usando la función sample(). Una vez creado ordena el vector por tamaño usando la función sort(). ¿Si quisieras invertir el orden de los elementos del vector que función utilizarías?

Para empezar primero vamos a leer la ayuda de las dos funciones que se nos ha especificado
```{r}
?sample()
```
La función sample recibe como argumento un vector o un valor numerico del que sacar elementos. En caso de ser un valor numerico sample toma valores del rango 1:x y en caso de ser un vector toma valores de ese vector especificado. Ademas recibe un valor size n entero positivo que especifica el numero de elementos a elegir, en caso de pasarle un vector en el anterior parametro si omitimos este parametro el rango es igual a la longitud del vector. Ademas de eso opcionalmente tenemos la posibilidad de hacer muesreo con o sin remplacamiento o de pasarle un vector de probabilidades en el muestreo

```{r}
?sort()
```
Esta función es mas simple que la anterior. Solo recibe como parametros el vector de elementos a ordenar y un booleano que indica si queremos ordenarlos en orden decreciente o en orden creciente

Con esta información podemos resolver el ejercicio de forma sencilla

```{r}
ej7 <- sample(10,10)
print(ej7)
```
Con el vector creado ordenarlo es tan sencillo como ejecutar la orden sort
```{r}
ej7 <- sort(ej7)
print(ej7)
```

Finalmente podemos invertir el orden de los elementos del vector ya ordenado utilizando la misma función sort pero indicando que el orden es descendiente

```{r}
sort(ej7,decreasing=TRUE)
```

Esto podemos hacerlo porque el vector esta ordenado. Si quisieramos hacer lo mismo para un vector desordenado tenemos la funcion rev()
```{r}
rev(ej7)
```

8.Crea un vector x que contenga los elementos -5,-1,0,1,2,3,4,5,6. Escribe un código del tipo x[algo], para extraer:

```{r}
ej8 <- c(-5,-1,0,1,2,3,4,5,6)
print(ej8)
```

- elementos de x menores que 0,
```{r}
ej8[ej8<0]
```
- elementos de x menores o igual que 0,
```{r}
ej8[ej8<=0]
```
- elementos of x mayor o igual que 3,
```{r}
ej8[ej8>=3]
```
- elementos de x menor que 0 o mayor que 4 
```{r}
ej8[(ej8<0) | (ej8>4)]
```
- elementos de x mayor que 0 y menor que 4
```{r}
ej8[(ej8>0) & (ej8<4)]
```
- elementos de x distintos de 0
```{r}
ej8[ej8!=0]
```

9. Crea los siguientes vectores x<-month.name[1:6] y z<-month.name[4:10] a partir del vector original month.name. Recupera los valores idénticos entre los vectores x y z usando %in%

En primer lugar creamos los vectores 

```{r}
ej9a<-month.name[1:6]
print(ej9a)
```

```{r}
ej9b<-month.name[4:10]
print(ej9b)
```

despues para recuperar los valores identicos utilizamos el operador %in%. Notese que este operador realmente nos devuelve un vector de booleanos del tamaño del operando de la izquierda donde el valor para cada elemento sera false si el elemento en la misma posicion del operando de la izquierda no esta contenido en el de la derecha y true si lo esta. Por tanto tenemos que utilizar este vector de booleanos para acceder a los valores unicos dentro del vector que hayamos utilizado a la izquierda

```{r}
ej9a[ej9a %in% ej9b]
```

10. R permite extraer elementos de un vector que satisfacen determinadas condiciones usando la función subset(). Para el vector x <- c(6,1:3,NA,12) calcula los elementos mayores que 5 en x usando:

```{r}
ej10 <- c(6,1:3,NA,12)
print(ej10)
```

- primero el filtrado normal es decir con el operador >

```{r}
  ej10[ej10>5]
```

Podemos observar que incluye el dato NA si quisieramos que no lo hiciera podemos utilizar

```{r}
ej10[ej10>5 & !(is.na(ej10))]
```

- después con la función subset()

```{r}
subset(ej10,ej10>5)
```

Observamos que la función subset nos permite filtrar ignorando los NA directamente