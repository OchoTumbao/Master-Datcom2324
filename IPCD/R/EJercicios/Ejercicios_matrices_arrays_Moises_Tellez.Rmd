---
title: "Ejercicios_matrices_Moises_Tellez"
author: "Moisés Téllez Francisco"
date: "2023-09-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Ejercicios matrices y arrays

1.  Dada la siguiente matrix:

laberinto <- matrix(c(
   "O", "X", "O", "O", "O",
   "O", "X", "X", "X", "O",
   "O", "O", "O", "O", "X",
   "X", "X", "X", "O", "X",
   "O", "O", "O", "O", "O"
 ), nrow = 5, byrow = TRUE)
 
```{r}
laberinto <- matrix(c(
   "O", "X", "O", "O", "O",
   "O", "X", "X", "X", "O",
   "O", "O", "O", "O", "X",
   "X", "X", "X", "O", "X",
   "O", "O", "O", "O", "O"
 ), nrow = 5, byrow = TRUE)
```

* Indique donde están las "X" usando la función which
```{r}
which(laberinto=="X")
```
* Indique donde están las "X" usando la función which pero usando el parámetro arr.ind
```{r}
which(laberinto=="X",arr.ind = TRUE)
```
* Indique cuantos valores 1 hay en la matriz
```{r}
length(which(laberinto==1))
```
* Reemplace las "X" por 1 y los "O" por 0 y convierta la matrix en una matrix numérica
```{r}
laberinto[laberinto=="X"] <- 1
laberinto[laberinto=="O"] <- 0
laberinto <- as.numeric(laberinto)
dim(laberinto) <- c(5,5)
print(laberinto)
```
* Indique si la matrix es simétrica
```{r}
isSymmetric(laberinto)
```
* Cree una nueva matrix con los valores en las filas y columnas pares 
```{r}
laberinto_pares<-matrix(data=0,nrow=5,ncol=5)
?seq
laberinto_pares[seq(2,dim(laberinto_pares)[1],2),seq(2,dim(laberinto_pares)[2],2)] <- 1
print(laberinto_pares)
```
* Indique cuantos valores 1 hay en la matriz
```{r}
length(which(laberinto_pares==1))
```

2. Crea una matriz que represente un Sudoku. Debe estar inicializada en NA. Luego rellenar solo un 10% de las casillas con un valor entre 1 y 9 (HINT: usa la función sample). No se preocupe de que sea un esquema válido (se pueden repetir valores en una fila por ejemplo... eso ya lo haremos más adelante...)

```{r}
sudoku <- matrix(NA,nrow = 9,ncol = 9)
sudoku[sample(length(sudoku),length(sudoku)*0.10)] <- sample(1:9,length(sudoku)*0.10,replace=T)
print(sudoku)
```

3. Teniendo estas dos matrices:

matriz <- matrix(sample(1:9, 30,replace=TRUE), nrow=5)

mascara <- matrix(sample(c(TRUE,FALSE), 30, replace=TRUE), nrow=5)

```{r}
matriz <- matrix(sample(1:9, 30,replace=TRUE), nrow=5)

mascara <- matrix(sample(c(TRUE,FALSE), 30, replace=TRUE), nrow=5)
```

* Aplique la máscara a la matrix, en donde si la posicion en la máscara es FALSE entonces el resultado es 0 y sino se mantiene su valor
```{r}
matriz_original <- matriz
matriz[mascara == FALSE] <- 0
print(matriz)
print(matriz_original)
```
* Calcule el producto de la matriz original por la matriz modificada traspuesta (NOTA: la matriz final será de 5x5)
```{r}
ej3 <- matriz_original %*% t(matriz)
print(ej3)
```

4. Crea un array 5D llamado "mi_array5D" con las siguientes características, rellénalo con números enteros consecutivos comenzando desde 1:
        Tamaño de la primera dimensión: 2 elementos
        Tamaño de la segunda dimensión: 3 elementos
        Tamaño de la tercera dimensión: 4 elementos
        Tamaño de la cuarta dimensión: 5 elementos
        Tamaño de la quinta dimensión: 6 elementos
```{r}
ej4 <- array(1:(2*3*4*5*6),dim=c(2,3,4,5,6))
print(length(ej4))
```
Accede a los siguientes elementos del array:
        los elementos pares (analice la posicion de esos valores en las 5 dimensiones)
```{r}
ej4[ej4 %% 2 == 0]
which(ej4 %% 2 == 0)
```
Los elementos pares son aquellos con indice par, por tanto podemos acceder a ellos usando los que tienen el indice impar
estudiando el caso anterior muestre los elementos impares sin usar ningun tipo de condicional, igualdad o desigualdad

```{r}
ej4[seq(1,2*3*4*5*6,2)]
```

Redimensiona el array para que tenga:
        Tamaño de la primera dimensión: 6 elementos.
        Tamaño de la segunda dimensión: 5 elementos.
        Tamaño de la tercera dimensión: 4 elementos.
        Tamaño de la cuarta dimensión: 3 elementos.
        Tamaño de la quinta dimensión: 2 elementos.
    
    ```{r}
    dim(ej4) <- c(6,5,4,3,2)
    print(ej4)
    ```

5. Supongamos que tenemos un grafo no dirigido con 6 nodos etiquetados del 1 al 6, y las siguientes aristas:
        Arista 1: (1, 2)
        Arista 2: (1, 3)
        Arista 3: (2, 4)
        Arista 4: (2, 5)
        Arista 5: (3, 6)
        Arista 6: (4, 5)

  Crea una matriz de adyacencia "matriz_adyacencia" en R para representar este grafo. En una matriz de adyacencia, las filas y columnas representan los nodos, y un valor 1 indica que existe una arista entre los nodos correspondientes, mientras que un valor 0 indica la ausencia de una arista.
```{r}
  ej5 <- matrix(0,nrow=6,ncol=6)
  ej5[1,2] <- 1
  ej5[1,3] <- 1
  ej5[2,1] <- 1
  ej5[3,1] <- 1
  ej5[2,4] <- 1
  ej5[4,2] <- 1
  ej5[2,5] <- 1
  ej5[5,2] <- 1
  ej5[3,6] <- 1
  ej5[6,3] <- 1
  ej5[4,5] <- 1
  ej5[5,4] <- 1
  print(ej5)
  
```
        Calcula el grado del nodo 4 en el grafo. El grado de un nodo es la cantidad de aristas que inciden en él.
```{r}
sum(ej5[4,])
```
        Encuentra todos los nodos adyacentes del nodo 2
```{r}
which(ej5[2,] == 1)
```
        Cuenta la cantidad de nodos que tiene una arista hacia si mismos (self-loop)
```{r}
sum(diag(ej5))
```

